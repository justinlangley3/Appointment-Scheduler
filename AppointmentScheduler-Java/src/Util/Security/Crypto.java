/*
 * Created By: 	Justin A. Langley
 * Course: 	C195 - Software II 
 * Language: 	Java
 *
 * @(#)Crypto.java   2021.05.19 at 06:08:36 EDT
 * Version: 1.0.0
 */



package Util.Security;

import java.math.BigInteger;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

//~--- classes ----------------------------------------------------------------

/*
* This class contains basic cryptographic features for securing user login data.
* It is included to provide mock application security features.
*
* Features:
* - Random 32-byte salt generation.
* - Hashing via MessageDigest object from java.security package using SHA-256 algorithm
* - Converting bytes to a hexadecimal representation in a byte array (for DB storage)
* - Provides at least minimum protection against: rainbow table attacks
* - If user data were exfiltrated from our MySQL DB, passwords would not be directly exposed
*
* Implementation Notes:
* The maximum password length is 32 bytes.
* For this reason a 32 byte fixed length salt was chosen.
* These values also correspond to SHA-256 having a 32 byte keyspace (256-bit),
* although, other hashing algorithms could have been chosen instead.
*
* These selections ensure minimum appropriate entropy.
* In the real world PBKDF2, with key stretching, would be a more ideal implementation.
* SHA-256 was chosen here for ease of implementation with the Java standard libraries
*
* Storage Requirements:
* A user's hash, and their unique, random salt are hexadecimal stored in a raw binary format
* Hash:  VARBINARY(64) in MySQL DB
* Salt:  VARBINARY(64) in MySQL DB
*
*
* As an example, compare these SHA-256 hashes with your favorite hash cracking website (i.e. crackstation.net)
*
* 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 ("test", with no salt)
* 6ba826659b11d14a287fb37d98ee31ac3f0288afd0fb1992a9cb2ecd8d9dbfc3 ("test", with random salt generated by this class)
* 922498635f607bccf7be5a894d82865323d5af95f3a6c4341f77d7efa5535ab1 ("test", with a different random salt)
* The first is easily decoded, but the other two are not. Notice they all derive from the same password!
*
* The beauty of random salting:
*     - multiple users can have the same password, but have a different hash in our MySQL DB
*     - a hash cannot be easily reversed
*     - protection primarily against rainbow table attacks
*
* IMPORTANT:
* Strong passwords still need to be chosen by users
* Salting and hashing is not an excuse for using weak passwords
* Otherwise, brute force and dictionary attacks are still feasible
*/

public class Crypto
{

    // static final SecureRandom for RNG is ok . . .
    // Each call to nextBytes() forces new self-seeding during runtime
    // Each new user created in the same instance will have a different salt, from a different seed
    // reference: https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html for more information
    private static final Random RAND = new SecureRandom();

    //~--- static initializers ------------------------------------------------

    static {}

    //~--- constructors -------------------------------------------------------

    // default constructor, all method calls are static, (i.e. we won't create objects of this class)
    public Crypto() {}

    //~--- inner classes ------------------------------------------------------

    // custom exception which can be thrown if authentication fails
    public static class AuthenticationException
            extends RuntimeException
    {
        public AuthenticationException(String errorMessage)
        {
            super(errorMessage);
        }
    }


    public static class Hash
    {

        // Generates a salted SHA-256 hash
        public static ArrayList<byte[]> generateHash(char[] input, byte[] salt) throws NoSuchAlgorithmException
        {

            // get input as bytes, and create a new byte array large enough to hold salted input
            byte[] inputBytes = Types.charToBytes(input);
            byte[] salted     = new byte [input.length + salt.length];

            // copy salt, then input, to newly created byte array
            System.arraycopy(salt, 0, salted, 0, salt.length);
            System.arraycopy(inputBytes, 0, salted, salt.length, inputBytes.length);

            try {

                // create a message digest object and set the algorithm to SHA256
                MessageDigest md = MessageDigest.getInstance("SHA-256");

                // mutate MessageDigest object to contain our salted byte array
                md.update(salted);

                // perform the hash, get hexadecimal representation, and store as bytes
                byte[] hash = new BigInteger(1, md.digest()).toString(16)
                                                            .getBytes();

                // build our ArrayList containing (hash, salt) for returning
                ArrayList<byte[]> data = new ArrayList<>(Arrays.asList(hash, salt));

                return data;
            } catch (NoSuchAlgorithmException e) {
                throw new RuntimeException(e);
            } finally {

                // clear sensitive data
                Arrays.fill(inputBytes, (byte) 0);
                Arrays.fill(salted, (byte) 0);
                Arrays.fill(input, Character.MIN_VALUE);
            }
        }

        // Generates a 32-byte random salt
        public static byte[] generateSalt()
        {

            // 32 byte array to contain salt
            byte[] bytes = new byte [32];

            // fill array with randomly generated bytes
            RAND.nextBytes(bytes);

            // convert to hexadecimal representation and store in a byte[]
            byte[] salt = new BigInteger(1, bytes).toString(16)
                                                  .getBytes();

            // clear the byte[] we used to generate a hex salt ... not for security purposes
            // we want the garbage collector to get rid of it, since we no longer need it
            Arrays.fill(bytes, (byte) 0);

            return salt;
        }

        //~--- get methods ----------------------------------------------------

        // Compare two hashes, one from the DB and the other generated here from a password input
        public static boolean isHashValid(char[] pword, byte[] expectedHash, byte[] salt)
                throws NoSuchAlgorithmException
        {
            ArrayList<byte[]> hash = generateHash(pword, salt);

            // return if hash matches the held database value as a boolean
            return (Arrays.equals(hash.get(0), expectedHash));
        }
    }


    // Inner class containing type conversions and encoding
    public static class Types
    {

        // Helper for converting char[] to byte[]
        public static byte[] charToBytes(char[] chars)
        {
            CharBuffer charBuffer = CharBuffer.wrap(chars);
            ByteBuffer byteBuffer = Charset.forName("UTF-8")
                                           .encode(charBuffer);
            byte[]     bytes      = Arrays.copyOfRange(byteBuffer.array(), byteBuffer.position(), byteBuffer.limit());

            // clear sensitive data
            Arrays.fill(byteBuffer.array(), (byte) 0);
            Arrays.fill(charBuffer.array(), Character.MIN_VALUE);

            return bytes;
        }

        public static String encodeHex(byte[] bytes)
        {
            String        hex     = hexBytesToString(bytes);
            StringBuilder encoded = new StringBuilder();

            for (int i = 0 ; i < hex.length() ; i += 2) {
                String h = hex.substring(i, i + 2);

                encoded.append((char) Integer.parseInt(h, 16));
            }

            return encoded.toString();
        }

        // Converts hexadecimal raw bytes from a byte[] to string
        public static String hexBytesToString(byte[] bytes)
        {
            StringBuilder hexString = new StringBuilder();

            for (byte b : bytes) {

                // convert byte to an integer masked by hex offset
                int value = (int) b & 0xff;

                // last 8 bits
                String hex = Integer.toHexString(value);

                // if only half of the byte is hex
                if (hex.length() % 2 == 1)
                {
                    hex = "0" + hex;
                }

                hexString.append(hex);
            }

            return hexString.toString();
        }
    }
}

/*
 * @(#)Crypto.java 2021.05.19 at 06:08:36 EDT
 * EOF
 */
